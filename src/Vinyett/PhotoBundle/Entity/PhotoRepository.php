<?php

namespace Vinyett\PhotoBundle\Entity;

use Doctrine\ORM\EntityRepository;
use Doctrine\ORM\Query\ResultSetMapping;
use Doctrine\ORM\Query;

use Vinyett\PhotoBundle\Entity\Photo;
use Vinyett\UserBundle\Entity\User;

/**
 * PhotoRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class PhotoRepository extends EntityRepository
{

    
    /*
     * Finds the four neighboring photos from a collection, group, or photostream and returns the objects back
     * to the controller (to be fed into the view).
     *
	 * @param integer $photo_id ID of the photo
	 * @param string $type (Collection, group, or photostream)
	 * @param integer $type_id ID of the $type, if applicable
	 
     * @return array
     */    
    public function findNeighboringPhotos($photo_id, $type = 'photostream', $type_id = null)
    {
        $em = $this->getEntityManager();
        
        //Because DQL does not support UNION, we just use native SQL and bind the results
        //to Doctrine.
        $dql = "(SELECT p.id, p.owner_id, p.date_posted, p.photo_path_square_50, u.id AS user_id, u.username FROM Photo p INNER JOIN User u ON u.id = p.owner_id WHERE p.id < ? AND p.owner_id = ? ORDER BY ID DESC LIMIT 2)
                 UNION
                (SELECT p.id, p.owner_id, p.date_posted, p.photo_path_square_50, u.id AS user_id, u.username FROM Photo p INNER JOIN User u ON u.id = p.owner_id WHERE p.id >= ? AND p.owner_id = ? ORDER BY ID ASC LIMIT 3) ORDER BY date_posted ASC";
                
        $rsm = new ResultSetMapping;
        $rsm->addEntityResult('Vinyett\PhotoBundle\Entity\Photo', 'p');
        
        $rsm->addFieldResult('p', 'id', 'id');
        $rsm->addFieldResult('p', 'date_posted', 'date_posted');
        $rsm->addFieldResult('p', 'photo_path_square_50', 'photo_path_square_50');
        
        $rsm->addJoinedEntityResult('Vinyett\UserBundle\Entity\User' , 'u', 'p', 'owner');
        
        $rsm->addFieldResult("u", "user_id", "id");
        $rsm->addFieldResult('u', 'username', 'username');
    
        $query = $em->createNativeQuery($dql, $rsm);
        $query->setParameters(array(1 => $photo_id, 2 => $type_id, 3 => $photo_id, 4 => $type_id));
    
        return $query->getResult();
        
    }
    
    
    /**
     * Fetches the photos by a user with an offset based on
     * how many objects are shown "per page"
     *
	 * @param UserBundle:User $user Current User Object
	 * @param array $options List of options
	 *
     * @return ArrayCollection
     */
    public function findPhotosBy($viewer, $follow, $user, $options = array()) 
    { 
        $offset = $options['on'];
        $per_page = $options['with'];
    
    
        $qb = $this->getPhotoQueryBuilderFromPerspective($viewer, $follow, $owner)
                   ->setFirstResult($offset)
                   ->setMaxResults($per_page);
                   
        return $qb->getQuery()->getArrayResult();
    }
    
    
    /**
     * Spits out a hydrated array for a photo to be pushed
     * back into the template or via the rest API.
     *
     * NOTE: Only photos by the owner will be returned (because FOR NOW
     * it is a raw dump of the photo table).
     *
	 * @param interger $id Photo ID 
	 *
     * @return array
     */
    public function findPhotoFor(User $owner, $id) 
    { 
        $qb = $this->createQueryBuilder("p")
                   ->where("p.owner = :owner")
                   ->andWhere("p.id = :id")
                   ->setMaxResults(1)
                   ->setParameters(array("owner" => $owner, "id" => $id));
                   
        return $qb->getQuery()->getSingleResult(Query::HYDRATE_ARRAY); //An array is easier to dump.
    }
    
    
    /**
     * Returns query builder for the photos in a persons stream. 
     * Fetches the users a person follows then gets the photos based on those...
     * 
     * @access public
     * @param mixed $user
     * @return void
     */
    public function getTimelineQueryBuilder($user) 
    { 
        $following = $this->getEntityManager()->getRepository("ConnectBundle:Follow")->findFollowing($user);
        $fid = array();
        foreach($following as $follow)
        { 
            $fid[] = $follow->getFollowing()->getId();
        }
        
        if(empty($fid)) 
        { 
            throw new \Exception("No timeline without followers available");
        }
        
        $qb = $this->createQueryBuilder("p");           
        $qb->addSelect(array("f", "f2"))
           ->addSelect("partial fp.{id, username, photo_square}")
           ->addSelect("CASE WHEN f.photo is NULL THEN false ELSE true END as is_favorited")
           ->where("p.owner in (:following)")
           ->andWhere('p.privacy_level = :privacy') //Right now only public photos.
           ->leftJoin("p.favorites", 'f', 'WITH', 'f.owner = :viewer')
           ->leftJoin("p.favorites", "f2", 'WITH', 'f2.owner != :viewer')
           ->leftJoin("f2.owner", "fp")
           ->orderBy("p.date_posted", "DESC")
           ->setParameters(array("following" => $fid, "viewer" => $user, "privacy" => 0));
           //->setMaxResults(30);
                   
        return $qb;
    }
    

    /**
     * Gets query builder for photos from a user by another users perspective
     *
	 * @param User $viewer Perspective to view from
	 * @param Follow $follow Following object (if exists to get a better perspective ;))
	 * @param User $owner Owner of the photos we're selecting...
	 *
     * @return Doctrine\ORM\Query
     */    
    public function getPhotosQueryFromPerspective($viewer, $follow, $owner) 
    { 
        return $this->getPhotoQueryBuilderFromPerspective($viewer, $follow, $owner)->getQuery();
    }
    
    
    
    /**
     * Gets query builder for photos from a user by another users perspective
     *
	 * @param User $viewer Perspective to view from
	 * @param Follow $follow Following object (if exists to get a better perspective ;))
	 * @param User $owner Owner of the photos we're selecting...
	 *
     * @return Doctrine\ORM\QueryBuilder
     */
    public function getPhotoQueryBuilderFromPerspective($viewer, $follow, $owner) 
    { 
        //Because of the way I have it set up (TEMPORARY!) we start with basic permissions
        //and work our way down by adding them based on things.
        
        //As soon as we do a little research, this will be shifted to Symfony ACL.
    
        $levels = array(0); //Everyone can see public...
        
        //First, we determine what photos we can get...
        if($viewer == $owner) //Owners can see them all
        { 
            $levels[] = 1;
            $levels[] = 2;
            $levels[] = 3;
            $levels[] = 4; 
        }
        if($follow) {
            if($viewer != $owner && $follow->getIsFriend() == true)
            { 
                $levels[] = 2; //friends can see friends & friends and family
                $levels[] = 4;
            }
            
            if($viewer != $owner && $follow->getIsFamily() == true)
            { 
                $levels[] = 3; //friends can see friends...
                $levels[] = 4; //and friends and family
            }
        }
            
        $qb = $this->createQueryBuilder("p");
                   
        $qb->addSelect(array("f", "f2"))
           ->addSelect("partial fp.{id, username, photo_square}")
           ->addSelect("CASE WHEN f.photo is NULL THEN false ELSE true END as is_favorited")
           ->where("p.owner = :owner")
           ->andWhere($qb->expr()->in('p.privacy_level', array_unique($levels)))
           ->leftJoin("p.favorites", 'f', 'WITH', 'f.owner = :viewer')
           ->leftJoin("p.favorites", "f2", 'WITH', 'f2.owner != :viewer')
           ->leftJoin("f2.owner", "fp")
           ->orderBy("p.date_posted", "DESC")
           ->setParameters(array("owner" => $owner, "viewer" => $viewer));
           //->setMaxResults(30);
                   
        return $qb;

    }    
    
    
    public function handleCollectionToken()
    { 
        $qb = $this->createQueryBuilder("p");
        $qb->where("p.owner = :owner")
           ->andWhere("p.date_posted");
    }
    
    
    

}